#include <fstream>
#include <filesystem>
#include <format>
#include "export.h"
#include "config.h"
#include "logging.h"
#include "utils.h"
#include "ear_clip.h"


static inline Logging::Logger& logger = Logging::Logger::getLogger("export");

using M2PConfig::g_config;

using namespace M2PExport;
namespace fs = std::filesystem;


void M2PExport::writeEntitiesToMap(const std::vector<M2PEntity::Entity>& entities)
{
	std::ofstream file{ "test/testout.map" };
	if (!file.good())
	{
		logger.error("Could not open \"test/testout.map\" for writing");
		exit(EXIT_FAILURE);
	}

	for (const M2PEntity::Entity& entity : entities)
	{
		file.write(entity.toString().c_str(), entity.toString().size());
	}

	file.close();
}

std::vector<ModelData> M2PExport::prepareModels(std::vector<M2PEntity::Entity>& entities, const M2PWad3::Wad3Handler& wadHandler)
{
	std::unordered_map<std::string, ModelData> modelsMap;
	for (M2PEntity::Entity& entity : entities)
	{
		if (entity.classname == "worldspawn")
		{
			if (!M2PConfig::isMap())
			{
				std::string wads;
				wads.reserve(1024);
				for (int i = 0; i < wadHandler.usedWads.size(); ++i) {
					const fs::path& wadPath = wadHandler.usedWads[i];
					std::string wadStr = "/" + fs::relative(wadPath, wadPath.root_path()).string();
					std::replace(wadStr.begin(), wadStr.end(), '\\', '/');
					wads.append(wadStr);
					if (i < wadHandler.usedWads.size() - 1)
						wads.append(";");
				}
				entity.keyvalues.emplace_back("wad", wads);
			}
			entity.keyvalues.emplace_back("_note", "Modified by Map2Prop");
		}

		if (entity.brushes.empty())
			continue;

		if (g_config.mapcompile && entity.classname != "func_map2prop")
			continue;

		std::string outname = !g_config.outputName.empty() ? g_config.outputName : g_config.inputFilepath.stem().string();
		if (!modelsMap.contains(outname))
		{
			modelsMap[outname].outname = outname;
			modelsMap[outname].triangles.reserve(64);
		}
		for (const M2PEntity::Brush& brush : entity.brushes)
		{
			for (const M2PEntity::Face& face : brush.faces)
			{
				M2PUtils::extendVector(modelsMap[outname].triangles, M2PGeo::earClip(face.vertices, face.normal, face.texture.name));
			}
		}
	}

	std::vector<ModelData> models;
	for (const auto& kv : modelsMap)
		models.push_back(kv.second);

	return models;
}


bool Smd::writeSmd(const ModelData& model)
{
	fs::path filepath = g_config.outputDir / (model.outname + ".smd");
	m_file.open(filepath);
	if (!m_file.is_open() || !m_file.good())
	{
		m_file.close();
		logger.warning("Could not open file for writing: " + filepath.string());
		return false;
	}

	logger.debug("Writing " + filepath.string());

	m_file << "version 1\nnodes\n0 \"root\" -1\nend\nskeleton\ntime 0\n0 0 0 0 0 0 0\nend\ntriangles\n";

	for (const M2PGeo::Triangle &triangle : model.triangles)
	{
		m_file << triangle.textureName << ".bmp\n";
		std::array<M2PGeo::Vertex, 3> vertices = {
			std::get<0>(triangle.vertices),
			std::get<1>(triangle.vertices),
			std::get<2>(triangle.vertices)
		};
		for (const M2PGeo::Vertex &vertex : vertices)
		{
			m_file << "0\t";
			const M2PGeo::Vector3& normal = vertex.normal;
			if (M2PConfig::isObj())
			{
				m_file << std::format("{:.6f} {:.6f} {:.6f}\t", vertex.x, -vertex.z, vertex.y);
				m_file << std::format("{:.6f} {:.6f} {:.6f}\t", normal.x, -normal.z, normal.y);
				m_file << std::format("{:.6f} {:.6f}", vertex.uv.x, vertex.uv.y + 1);
			}
			else
			{
				m_file << std::format("{:.6f} {:.6f} {:.6f}\t", vertex.x, vertex.y, vertex.z);
				m_file << std::format("{:.6f} {:.6f} {:.6f}\t", normal.x, normal.y, normal.z);
				m_file << std::format("{:.6f} {:.6f}", vertex.uv.x, vertex.uv.y + 1);
			}
			m_file << "\n";
		}
	}
	m_file << "end\n";
	m_file.close();

	logger.info("Successfully written " + filepath.string());
	return true;
}

bool Qc::writeQc(const ModelData& model)
{
	fs::path filepath = g_config.outputDir / (model.outname + ".qc");
	m_file.open(filepath);
	if (!m_file.is_open() || !m_file.good())
	{
		m_file.close();
		logger.warning("Could not open file for writing: " + filepath.string());
		return false;
	}

	std::string rendermodes{ "" };
	std::string offset{ "0 0 0" };
	std::string qcFlags = model.qcFlags ? std::format("$flags {}\n", model.qcFlags) : "";
	std::string bbox{ "" };
	std::string cbox{ "" };

	logger.debug("Writing " + filepath.string());

	m_file << "/*\n Automatically generated by Erty's GoldSrc Map2Prop.\n*/\n\n";
	m_file << "$modelname " << model.subdir << model.outname << ".mdl\n";
	m_file << "$cd \".\"\n$cdtexture \".\"\n";
	m_file << "$scale " << model.scale << "\n";
	m_file << "$origin " << offset << " " << model.rotation << "\n";
	m_file << qcFlags << rendermodes << bbox << cbox << "$gamma " << g_config.qcGamma << "\n";
	m_file << "$body studio \"" << model.outname << "\"\n";
	m_file << "$sequence \"Generated_with_Erty's_Map2Prop\" \"" << model.outname << "\"\n";

	m_file.close();

	logger.info("Successfully written " + filepath.string());
	return true;
}

static inline int compileModel(const ModelData& model)
{
	fs::path currentDir = fs::absolute(fs::current_path());
	fs::current_path(fs::current_path() / g_config.outputDir);
	int returnCode = std::system((g_config.studiomdl.string() + " " + model.outname + ".qc").c_str());
	fs::current_path(currentDir);
	return returnCode;
}

int M2PExport::processModels(const std::vector<ModelData>& models, bool missingTextures)
{
	int returnCodes = 0;

	logger.debug(std::format("Processing {} model{}", models.size(), models.size() > 1 ? "s" : ""));

	for (const ModelData& model : models)
	{
		bool smdOk = Smd().writeSmd(model);
		bool qcOk = Qc().writeQc(model);
	}

	logger.info(std::format("Finished processing {} model{}", models.size(), models.size() > 1 ? "s" : ""));

	if (!g_config.autocompile)
		return 0;

	logger.info(std::string{ "Autocompile enabled, compiling model" } + (models.size() > 1 ? "s" : "") + "...");

	if (missingTextures)
	{
		logger.warning("Cannot compile model, model has missing textures. Check logs for more info");
		return 1;
	}
	if (g_config.studiomdl.empty())
	{
		logger.warning("Cannot compile model, StudioMDL path not specified");
		return 1;
	}
	if (!fs::exists(g_config.studiomdl))
	{
		logger.warning("Cannot compile model, StudioMDL \"" + g_config.studiomdl.string() + "\" does not exist");
		return 1;
	}

	for (const ModelData& model : models)
	{
		returnCodes += compileModel(model);
	}

	if (returnCodes > 0)
		logger.warning("Something went wrong during compilation. Check logs for more info");
	else
		logger.info(std::format("Finished compiling {} model{}", models.size(), models.size() > 1 ? "s" : ""));

	return returnCodes;
}
